/*
 * Moov Identity API
 *
 * Handles all identities for tracking the users of the Moov platform.
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package identity

import (
	"context"
	"database/sql"
	"fmt"
	"os"

	"github.com/gorilla/mux"
	_ "github.com/moov-io/identity" // need to import the embedded files

	"github.com/go-kit/kit/log"
	api "github.com/moov-io/identity/pkg/api"
	"github.com/moov-io/identity/pkg/authn"
	configpkg "github.com/moov-io/identity/pkg/config"
	"github.com/moov-io/identity/pkg/credentials"
	"github.com/moov-io/identity/pkg/database"
	"github.com/moov-io/identity/pkg/identities"
	"github.com/moov-io/identity/pkg/invites"
	"github.com/moov-io/identity/pkg/notifications"
	"github.com/moov-io/identity/pkg/stime"
	"github.com/moov-io/identity/pkg/webkeys"
	"github.com/moov-io/identity/pkg/zerotrust"
)

type Environment struct {
	Logger log.Logger
	Config IdentityConfig

	InviteService invites.InvitesService

	PublicRouter  mux.Router
	PrivateRouter mux.Router
}

func NewEnvironment(configOverride *IdentityConfig) (*Environment, error) {

	logger := log.NewLogfmtLogger(log.NewSyncWriter(os.Stderr))

	var config *IdentityConfig
	if configOverride != nil {
		config = configOverride
	} else {
		ConfigService := configpkg.NewConfigService(logger)

		config = &IdentityConfig{}
		if err := ConfigService.Load(config); err != nil {
			return nil, err
		}
	}

	//db setup
	db, close := initializeDatabase(logger, config.Database)
	defer close()

	TimeService := stime.NewSystemTimeService()

	FrontchannelJwks, err := webkeys.NewWebKeysService(logger, config.Authentication.Frontchannel)
	if err != nil {
		logger.Log("main", "Unable to load up up the Frontchannel JSON Web Key Set")
		return nil, err
	}

	BackchannelJwks, err := webkeys.NewWebKeysService(logger, config.Authentication.Backchannel)
	if err != nil {
		logger.Log("main", "Unable to load up the Backchannel JSON Web Key Set")
		return nil, err
	}

	TokenService := authn.NewTokenService(TimeService, FrontchannelJwks, config.Authentication.Frontchannel.Expiration)

	NotificationsService := notifications.NewNotificationsService(config.Notifications)

	IdentityRepository := identities.NewIdentityRepository(db)
	IdentitiesService := identities.NewIdentitiesService(TimeService, IdentityRepository)

	CredentialRepository := credentials.NewCredentialRepository(db)
	CredentialsService := credentials.NewCredentialsService(TimeService, CredentialRepository)

	InvitesRepository := invites.NewInvitesRepository(db)
	InvitesService := invites.NewInvitesService(config.Invites, TimeService, InvitesRepository, NotificationsService)

	InternalService := authn.NewInternalService(*CredentialsService, *IdentitiesService, TokenService)

	// internal server
	InternalController := authn.NewInternalAPIController(InternalService)
	privateRouter := api.NewRouter(InternalController)

	// public server

	// auth middleware for the back channel
	AuthMiddleware, err := zerotrust.NewJWTMiddleware(BackchannelJwks)
	if err != nil {
		logger.Log("main", fmt.Sprintf("Can't startup the front channel middleware - %s", err))
		return nil, err
	}

	// debug api
	WhoAmIController := authn.NewWhoAmIController()

	IdentitiesController := identities.NewIdentitiesApiController(IdentitiesService)
	CredentialsController := credentials.NewCredentialsApiController(CredentialsService)
	InvitesController := invites.NewInvitesController(InvitesService)
	publicRouter := api.NewRouter(IdentitiesController, CredentialsController, InvitesController, WhoAmIController)

	// Add the auth middleware.
	publicRouter.Use(AuthMiddleware.Handler)

	env := Environment{
		Logger: logger,
		Config: *config,

		PublicRouter:  *publicRouter,
		PrivateRouter: *privateRouter,
	}

	return &env, nil
}

func initializeDatabase(logger log.Logger, config database.DatabaseConfig) (*sql.DB, func()) {
	ctx, cancelFunc := context.WithCancel(context.Background())

	// migrate database
	db, err := database.New(ctx, logger, config)
	if err != nil {
		panic(fmt.Sprintf("error creating database: %v", err))
	}

	shutdown := func() {
		cancelFunc()
		if err := db.Close(); err != nil {
			logger.Log("exit", err)
		}
	}

	if err := database.RunMigrations(db, config); err != nil {
		panic(fmt.Sprintf("Error running migrations: %s", err))
	}

	return db, shutdown
}
